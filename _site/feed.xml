<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-03-11T09:08:43+08:00</updated><id>http://localhost:4000/</id><entry><title type="html">MongoDB 简单命令行操作</title><link href="http://localhost:4000/db/2017/12/11/mongodb-base.html" rel="alternate" type="text/html" title="MongoDB 简单命令行操作" /><published>2017-12-11T00:00:00+08:00</published><updated>2017-12-11T00:00:00+08:00</updated><id>http://localhost:4000/db/2017/12/11/mongodb-base</id><content type="html" xml:base="http://localhost:4000/db/2017/12/11/mongodb-base.html">&lt;p&gt;首先是下载Mongodb进行安装、配置、启动。网上都是安装与配置教程，这里就不多说，直接做个mongodb的基本命令行的笔记。&lt;/p&gt;

&lt;p&gt;通过某些配置后，可以在cmd中输入services.msc打开服务面板。手动开启Mongodb服务，如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ozc5dgoun.bkt.clouddn.com/mongodb%E5%BC%80%E5%90%AF.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;正在开启中…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ozc5dgoun.bkt.clouddn.com/mongodb%E5%90%AF%E5%8A%A8%E4%B8%AD.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;开启之后，cmd中输入mongo启动mongodb ，开启mongo终端，这时候你就可以输入简单的命令来对mongodb进行操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ozc5dgoun.bkt.clouddn.com/mongodbBin.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;1创建数据库&quot;&gt;1.创建数据库&lt;/h3&gt;

&lt;p&gt;如果数据库存不存在，则创建数据库，否则切换到指定的数据库：&lt;/p&gt;
&lt;pre&gt;
	&amp;gt; use xmtdb
	switched to db xmtdb
&lt;/pre&gt;

&lt;h3 id=&quot;2删除数据库&quot;&gt;2.删除数据库&lt;/h3&gt;

&lt;p&gt;删除当前数据库，默认为test&lt;/p&gt;
&lt;pre&gt;db.dropDatabase()&lt;/pre&gt;

&lt;p&gt;例：删除指定数据库xmtdb&lt;/p&gt;

&lt;p&gt;1.查看所有数据库&lt;/p&gt;

&lt;pre&gt;&amp;gt; show dbs&lt;/pre&gt;

&lt;p&gt;2.切换到数据库xmtdb&lt;/p&gt;

&lt;pre&gt;&amp;gt; use xmtdb&lt;/pre&gt;

&lt;p&gt;3.执行删除命令:&lt;/p&gt;

&lt;pre&gt;&amp;gt; db.dropDatabase()&lt;/pre&gt;

&lt;p&gt;4.最后，通过show dbs命令来查看数据库是否删除成功了&lt;/p&gt;

&lt;h3 id=&quot;3查看数据库&quot;&gt;3.查看数据库&lt;/h3&gt;

&lt;pre&gt;&amp;gt; show dbs&lt;/pre&gt;

&lt;p&gt;&lt;span style=&quot;color:red;&quot;&gt;注：&lt;/span&gt;
刚新创建的数据库xmtdb,如果查看数据库xmtdb时，并没有在数据库列表中，要显示它，则需要向xmtdb数据库插入一些数据。&lt;/p&gt;

&lt;pre&gt;
&amp;gt; db.xmtdb.insert({&quot;name&quot;:&quot;嘻嘻哈哈徐小婷&quot;})
WriteResult({&quot;nInserted&quot;:1})
//这时候 &amp;gt; show dbs 时就有刚新创建的数据库
&lt;/pre&gt;

&lt;h3 id=&quot;4创建集合&quot;&gt;4.创建集合&lt;/h3&gt;

&lt;pre&gt;
方法1. db.createCollection('xmt')
方法2. db.xmt.insert({name:'xmt'})
&lt;/pre&gt;

&lt;h3 id=&quot;5查看集合&quot;&gt;5.查看集合&lt;/h3&gt;

&lt;pre&gt;&amp;gt; show collections&lt;/pre&gt;
&lt;p&gt;在数据库xmtdb中，插入一个集合xmt(新建一个集合=新建一个表)&lt;/p&gt;

&lt;h3 id=&quot;6删除集合&quot;&gt;6.删除集合&lt;/h3&gt;

&lt;p&gt;删除xmt这个集合&lt;/p&gt;

&lt;pre&gt;&amp;gt; db.xmt.drop()&lt;/pre&gt;

&lt;h3 id=&quot;7向集合中插入文档&quot;&gt;7.向集合中插入文档&lt;/h3&gt;

&lt;pre&gt;
&amp;gt;db.xmt.insert({userName:'anna',userAge:20,class:{name:'classA',numb:20}})
&amp;gt;db.xmt.insert({userName:'tj',userAge:25,class:{name:'classB',numb:30})
&lt;/pre&gt;

&lt;h3 id=&quot;8删除文档---删除集合中的username-为-anna的一条数据&quot;&gt;8.删除文档 - 删除集合中的userName 为 anna的一条数据&lt;/h3&gt;

&lt;pre&gt;db.xmt.remove({userName:'anna'})&lt;/pre&gt;

&lt;h3 id=&quot;9更新文档---修改xmt集合中名字为anna的数据用户年龄改为25&quot;&gt;9.更新文档 - 修改xmt集合中名字为anna的数据用户年龄改为25&lt;/h3&gt;

&lt;pre&gt;db.xmt.update({userName:'anna'},{$set:{userAge:25}})&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;修改子文档里面的内容 - 修改用户名为anna的那条数据的班级名称为ClassC&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;db.xmt.update({'userName':'anna'},{$set:{'class.name':'ClassC'}})&lt;/pre&gt;

&lt;h3 id=&quot;10查看文档&quot;&gt;10.查看文档&lt;/h3&gt;

&lt;p&gt;(1).查看某个集合的内容&lt;/p&gt;

&lt;pre&gt;db.xmt.find()&lt;/pre&gt;

&lt;p&gt;(2).查看格式化后的数据&lt;/p&gt;

&lt;pre&gt;db.xmt.find().pretty()&lt;/pre&gt;

&lt;p&gt;(3).查看第一条数据&lt;/p&gt;

&lt;pre&gt;db.xmt.findOne()&lt;/pre&gt;

&lt;p&gt;(4).查看子文档&lt;/p&gt;

&lt;pre&gt;db.xmt.find({'class.name':'classB'})&lt;/pre&gt;

&lt;p&gt;(5).查找年龄大于20的数据&lt;/p&gt;

&lt;pre&gt;db.xmt.find({age:{$gt:20}})&lt;/pre&gt;

&lt;p&gt;(6).查看年龄小于20的数据&lt;/p&gt;

&lt;pre&gt;db.xmt.find({age:${lt:20}})&lt;/pre&gt;

&lt;p&gt;具体可以查看菜鸟文档&lt;a href=&quot;http://www.runoob.com/mongodb&quot;&gt;http://www.runoob.com/mongodb&lt;/a&gt;&lt;/p&gt;</content><author><name>MengTing Xu</name></author><category term="db" /><category term="documentation" /><category term="sample" /><summary type="html">首先是下载Mongodb进行安装、配置、启动。网上都是安装与配置教程，这里就不多说，直接做个mongodb的基本命令行的笔记。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3E%22cutting.jpg%22,%20%22teaser%22=%3E%22cutting-teaser.jpg%22,%20%22credit%22=%3Enil,%20%22creditlink%22=%3E%22%22%7D" /></entry><entry><title type="html">使用github和jekyll设置自己的个人网站</title><link href="http://localhost:4000/git/2017/11/06/my-first-jekyll-blog.html" rel="alternate" type="text/html" title="使用github和jekyll设置自己的个人网站" /><published>2017-11-06T00:00:00+08:00</published><updated>2017-11-06T00:00:00+08:00</updated><id>http://localhost:4000/git/2017/11/06/my-first-jekyll-blog</id><content type="html" xml:base="http://localhost:4000/git/2017/11/06/my-first-jekyll-blog.html">&lt;p&gt;一直想写个属于自己的博客，又由于自己平时太懒也没啥心思弄，所以一直搁置着，直到最近…突然好想搭建个个人主页网站，自己对个人主页的要求并不是很高，简洁大方清晰就行了，为了方便，所以最后选择了使用Github Page.&lt;/p&gt;

&lt;h2 id=&quot;开始&quot;&gt;开始&lt;/h2&gt;

&lt;h3 id=&quot;目录&quot;&gt;目录&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;介绍
    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#什么是jekyll&quot;&gt;什么是Jekyll&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;安装
    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#github搭建&quot;&gt;GitHub搭建&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#jekyll本地环境搭建&quot;&gt;Jekyll本地环境搭建&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#目录结构&quot;&gt;目录结构&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#下载jekyll模板&quot;&gt;下载jekyll模板&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;什么是jekyll&quot;&gt;什么是jekyll&lt;/h3&gt;

&lt;p&gt;Jekyll是一个简单的博客形态和静态站点生产机器.它有一个模版目录，其中包含原始文本格式的文档，通过一个转换器（如 Markdown）和我们的 Liquid 渲染器转化成一个完整的可发布的静态网站,你可以发布在任何你喜爱的服务器上.Jekyll 也可以运行在 GitHub Page 上,也就是说,你可以使用 GitHub 的服务来搭建你的项目页面、博客或者网站,而且是完全免费的.你可以去&lt;a href=&quot;http://jekyllcn.com&quot;&gt;中文官网 To Lean Jekyll&lt;/a&gt;上学习它!&lt;/p&gt;

&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;

&lt;h3 id=&quot;github搭建&quot;&gt;github搭建&lt;/h3&gt;

&lt;p&gt;要用github pages, 首先注册&lt;a href=&quot;https://github.com/&quot;&gt;github帐号&lt;/a&gt;,github是个非常优秀的代码仓库,里面有很多优秀的开源项目,你可以找到你想要知道的以及对你非常有益的代码,你可以分享也可以学习,这个我的Github:&lt;a href=&quot;https://github.com/xmtgithub123&quot;&gt;https://github.com/xmtgithub123&lt;/a&gt;,欢迎大家fork &amp;amp;&amp;amp; star,哈哈哈！&lt;/p&gt;

&lt;h3 id=&quot;1下面是github的操作流程图&quot;&gt;(1).下面是github的操作流程图:&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://ozc5dgoun.bkt.clouddn.com/githubReg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;jekyll本地环境搭建&quot;&gt;jekyll本地环境搭建&lt;/h3&gt;

&lt;h4 id=&quot;1安装ruby环境&quot;&gt;(1).安装Ruby环境&lt;/h4&gt;

&lt;p&gt;网上教程蛮多的,大家可以参考网上的教程按步骤来实现,在这里放一个ruby的官网链接 &lt;a href=&quot;https://rubyinstaller.org/downloads/&quot;&gt;RubyInstaller&lt;/a&gt;,下载-&amp;gt;安装-&amp;gt;检测,打开命令工具:&lt;/p&gt;

&lt;pre&gt;检测ruby是否已经安装完毕,输入:ruby -v  //若有版本号出现则说明已经安装成功,反之安装失败&lt;/pre&gt;

&lt;h4 id=&quot;2安装rubydevkit环境&quot;&gt;(2).安装RubyDevKit环境&lt;/h4&gt;

&lt;p&gt;还是在个链接下,下载rubyDevkit安装包，安装在C:\RubyDevKit下,初始化:&lt;/p&gt;

&lt;pre&gt;ruby dk.rb init&lt;/pre&gt;

&lt;pre&gt;ruby dk.rb install&lt;/pre&gt;

&lt;h4 id=&quot;3安装jekyll环境&quot;&gt;(3).安装Jekyll环境&lt;/h4&gt;

&lt;p&gt;打开命令行输入命令如下：&lt;/p&gt;

&lt;pre&gt;gem install jekyll&lt;/pre&gt;

&lt;p&gt;而这个时候命令工具中会报错:&lt;/p&gt;

&lt;pre&gt;ERROR:  Could not find a valid gem 'jekyll' (&amp;gt;= 0), here is why:
        Unable to download data from http://ruby.taobao.org/ - bad response Not Found 404 (http://ruby.taobao.org/latest_specs.4.8.gz)
&lt;/pre&gt;

&lt;p&gt;这个错误说明你之前安装包的时候用了淘宝镜像,所以会报错;此时,你应该进行镜像更换:&lt;/p&gt;

&lt;pre&gt;gem source -r https://ruby.taobao.org/ (移除淘宝镜像)&lt;/pre&gt;

&lt;pre&gt;gem source -a https://rubygems.org/ (添加新镜像)&lt;/pre&gt;

&lt;p&gt;安装成功,可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;gem source&lt;/code&gt;来查看当前镜像:&lt;/p&gt;

&lt;pre&gt; *** CURRENT SOURCES ***
 https://rubygems.org/   //出现如下信息则说明安装成功&lt;/pre&gt;

&lt;p&gt;另一种情况是,安装rubygem 的镜像也有问题,也会提示如下信息:&lt;/p&gt;

&lt;pre&gt;
    ERROR:  Could not find a valid gem 'jekyll' (&amp;gt;= 0), here is why:
        Unable to download data from http://ruby.taobao.org/ - SSL_connetc retuned=1 errn=0 state=SSLv3 server certificate B:certificate verify failed(https://api.rubygems.org/specs.4.8.gz)
&lt;/pre&gt;

&lt;p&gt;解决方法如下:&lt;/p&gt;

&lt;pre&gt;删除原gem源: gem sources --remove https://rubygems.org/&lt;/pre&gt;

&lt;pre&gt;添加国内源: gem sources -a http://gems.ruby-china.org/&lt;/pre&gt;

&lt;p&gt;安装成功,可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;gem source&lt;/code&gt;来查看当前镜像:&lt;/p&gt;

&lt;pre&gt; *** CURRENT SOURCES ***
 http://gems.ruby-china.org/g/   //出现如下信息则说明安装成功&lt;/pre&gt;

&lt;p&gt;以上,安装完毕之后, 执行:&lt;/p&gt;

&lt;pre&gt;
&amp;gt; gem install jekyll bundler
&amp;gt; jekyll new my-awesome-site
&amp;gt; cd my-awesome-site
&amp;gt; bundle install
&amp;gt; bundle exec jekyll serve
&lt;/pre&gt;

&lt;p&gt;最后你可以通过打开浏览器 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:4000&lt;/code&gt; 来访问一个新的jekyll项目啦.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ozc5dgoun.bkt.clouddn.com/jekyll-pic.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;目录结构&quot;&gt;目录结构&lt;/h3&gt;

&lt;p&gt;你可以去看jekyll的完整文档, 小的为您奉上链接=&amp;gt;右边爆击&lt;a href=&quot;https://jekyllrb.com/docs/structure/&quot;&gt;Jekyll 文档英文版&lt;/a&gt; &amp;amp;&amp;amp; &lt;a href=&quot;http://jekyllcn.com/&quot;&gt;jekyll 文档中文版&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
├── _data                      &lt;span class=&quot;c&quot;&gt;# 格式化好的网站数据&lt;/span&gt;
|  └── authors.yml             &lt;span class=&quot;c&quot;&gt;# authors的一些基础信息变量&lt;/span&gt;
|  └── settings.yml            
├── _includes                  &lt;span class=&quot;c&quot;&gt;# 加载这些包含部分到你的布局或文章中方便重用&lt;/span&gt;
├── _layouts                   &lt;span class=&quot;c&quot;&gt;# 布局-包裹外部的模板&lt;/span&gt;
├── _posts                     &lt;span class=&quot;c&quot;&gt;# 放置你的文章&lt;/span&gt;
├── assets                     &lt;span class=&quot;c&quot;&gt;# 样式或图片文件&lt;/span&gt;
|  ├── css
|  |  └── main.css
|  |  └── syntax.css
|  └── img
├── menu                       &lt;span class=&quot;c&quot;&gt;# Menu pages&lt;/span&gt;
├── _config.yml                &lt;span class=&quot;c&quot;&gt;# 网站配置数据&lt;/span&gt;
└── index.md                   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;下载jekyll模板&quot;&gt;下载jekyll模板&lt;/h3&gt;

&lt;p&gt;jekyll 模板地址：&lt;a href=&quot;http://jekyllthemes.org/&quot;&gt;http://jekyllthemes.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下载自己喜欢的风格,拷贝到你的项目里,然后&lt;code class=&quot;highlighter-rouge&quot;&gt;git commit &lt;/code&gt;到你的github上,&lt;code class=&quot;highlighter-rouge&quot;&gt;git push origin master&lt;/code&gt;后,就可以在自己的github pages上看到效果啦.&lt;/p&gt;</content><author><name>MengTing Xu</name></author><category term="git" /><category term="documentation" /><category term="sample" /><summary type="html">一直想写个属于自己的博客，又由于自己平时太懒也没啥心思弄，所以一直搁置着，直到最近…突然好想搭建个个人主页网站，自己对个人主页的要求并不是很高，简洁大方清晰就行了，为了方便，所以最后选择了使用Github Page.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3E%22cutting.jpg%22,%20%22teaser%22=%3E%22cutting-teaser.jpg%22,%20%22credit%22=%3Enil,%20%22creditlink%22=%3E%22%22%7D" /></entry><entry><title type="html">H5 小游戏 (移动端)</title><link href="http://localhost:4000/project/2017/08/18/project-for-h5-games.html" rel="alternate" type="text/html" title="H5 小游戏 (移动端)" /><published>2017-08-18T00:00:00+08:00</published><updated>2017-08-18T00:00:00+08:00</updated><id>http://localhost:4000/project/2017/08/18/project-for-h5-games</id><content type="html" xml:base="http://localhost:4000/project/2017/08/18/project-for-h5-games.html">&lt;h3 id=&quot;一简介&quot;&gt;一、简介&lt;/h3&gt;

&lt;p&gt;该H5是个嵌套在淘宝活动互动动画页。整个画风卡哇伊。&lt;/p&gt;

&lt;h3 id=&quot;二项目地址&quot;&gt;二、项目地址&lt;/h3&gt;

&lt;p&gt;项目github地址：&lt;a href=&quot;https://github.com/xmtgithub123/MyThreeSquirrels&quot;&gt;https://github.com/xmtgithub123/MyThreeSquirrels&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;三项目截图&quot;&gt;三、项目截图&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://ozc5dgoun.bkt.clouddn.com/ts.jpg&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;http://ozc5dgoun.bkt.clouddn.com/ts.jpg&quot; alt=&quot;&quot; /&gt;
&lt;/a&gt;&lt;/p&gt;</content><author><name>XuMT</name></author><category term="project" /><category term="documentation" /><category term="sample" /><summary type="html">一、简介</summary></entry><entry><title type="html">项目管理标准版</title><link href="http://localhost:4000/project/2017/04/16/project-management-software.html" rel="alternate" type="text/html" title="项目管理标准版" /><published>2017-04-16T00:00:00+08:00</published><updated>2017-04-16T00:00:00+08:00</updated><id>http://localhost:4000/project/2017/04/16/project-management-software</id><content type="html" xml:base="http://localhost:4000/project/2017/04/16/project-management-software.html">&lt;h3 id=&quot;一简介&quot;&gt;一、简介&lt;/h3&gt;

&lt;p&gt;项目管理软件 - 工程项目管理软件,主要有经营管理、协同设计、绩效管理、综合办公、人事管理、系统管理等等模块,功能丰富,操作方便(内部管理软件)。&lt;/p&gt;

&lt;h3 id=&quot;二项目截图&quot;&gt;二、项目截图&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://ozc5dgoun.bkt.clouddn.com/jq-01.jpg&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;http://ozc5dgoun.bkt.clouddn.com/jq-01.jpg&quot; alt=&quot;&quot; /&gt;
&lt;/a&gt;
&lt;a href=&quot;http://ozc5dgoun.bkt.clouddn.com/jq-02.jpg&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;http://ozc5dgoun.bkt.clouddn.com/jq-02.jpg&quot; alt=&quot;&quot; /&gt;
&lt;/a&gt;&lt;/p&gt;</content><author><name>XuMT</name></author><category term="project" /><category term="documentation" /><category term="sample" /><summary type="html">一、简介</summary></entry><entry><title type="html">Meke 每刻 ( 移动端 )</title><link href="http://localhost:4000/project/2017/03/28/project-for-meke.html" rel="alternate" type="text/html" title="Meke 每刻 ( 移动端 )" /><published>2017-03-28T00:00:00+08:00</published><updated>2017-03-28T00:00:00+08:00</updated><id>http://localhost:4000/project/2017/03/28/project-for-meke</id><content type="html" xml:base="http://localhost:4000/project/2017/03/28/project-for-meke.html">&lt;h3 id=&quot;一简介&quot;&gt;一、简介&lt;/h3&gt;

&lt;p&gt;Meke 每刻 一款移动端app活动发布社交平台,可以像朋友圈那样发布和阅览新动态,可以查看附近的店铺及详情。该项目预启动但未完成(已实现登录、注册、首页、详情、发布、上传图片、个人中心等模块)。本项目主要使用VueJS2.0 + webpack 等技术栈。&lt;/p&gt;

&lt;h3 id=&quot;二项目截图&quot;&gt;二、项目截图&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://ozc5dgoun.bkt.clouddn.com/mk_01.jpg&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;http://ozc5dgoun.bkt.clouddn.com/mk_01.jpg&quot; alt=&quot;&quot; /&gt;
&lt;/a&gt;&lt;/p&gt;</content><author><name>XuMT</name></author><category term="project" /><category term="documentation" /><category term="sample" /><summary type="html">一、简介</summary></entry><entry><title type="html">你不知道的javascript学习笔记</title><link href="http://localhost:4000/js/2017/01/15/base-js-note.html" rel="alternate" type="text/html" title="你不知道的javascript学习笔记" /><published>2017-01-15T00:00:00+08:00</published><updated>2017-01-15T00:00:00+08:00</updated><id>http://localhost:4000/js/2017/01/15/base-js-note</id><content type="html" xml:base="http://localhost:4000/js/2017/01/15/base-js-note.html">&lt;p&gt;好记性不如烂笔头，又重温一变你不知道的js，为防止自己记性出现短暂性失忆，哈哈，所以记下相关基础的知识点，知识点有但内容不全，主要是自己觉得自己一看就能理解的重要点，本文章主要参考《你不知道的javascript》,感谢这本书和作者。路过的朋友也可以学习一下！&lt;/p&gt;

&lt;h2 id=&quot;开始&quot;&gt;开始&lt;/h2&gt;

&lt;h3 id=&quot;目录&quot;&gt;目录&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;作用域是什么
    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#理解作用域&quot;&gt;理解作用域&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#作用域嵌套&quot;&gt;作用域嵌套&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#会发生的异常&quot;&gt;会发生的异常&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;词法作用域
    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#词法阶段&quot;&gt;词法阶段&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#欺骗词法&quot;&gt;欺骗词法&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;函数作用域和块作用域
    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#函数中的作用域&quot;&gt;函数中的作用域&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#隐藏内部实现&quot;&gt;隐藏内部实现&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#函数作用域&quot;&gt;函数作用域&lt;/a&gt;
        &lt;ol&gt;
          &lt;li&gt;&lt;a href=&quot;#匿名和具名&quot;&gt;匿名和具名&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#立即执行函数表达示&quot;&gt;立即执行函数表达示&lt;/a&gt;&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#块作用域&quot;&gt;块作用域&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#提升&quot;&gt;提升&lt;/a&gt;
    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#变量提升&quot;&gt;变量提升&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#函数提升&quot;&gt;函数提升&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#函数优先&quot;&gt;函数优先&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;关于this
    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#调用的位置&quot;&gt;调用的位置&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#绑定规则&quot;&gt;绑定规则&lt;/a&gt;
        &lt;ol&gt;
          &lt;li&gt;&lt;a href=&quot;#默认绑定&quot;&gt;默认绑定&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#隐式绑定&quot;&gt;隐式绑定&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#显式绑定&quot;&gt;显式绑定&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#new绑定&quot;&gt;new绑定&lt;/a&gt;&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#优先级&quot;&gt;优先级&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#绑定例外&quot;&gt;绑定例外&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;理解作用域&quot;&gt;理解作用域&lt;/h3&gt;

&lt;p&gt;对程序的处理需要这三个帮手：&lt;br /&gt;
1.引擎：负责整个js程序的编译及执行过程&lt;br /&gt;
2.编译器：负责语法分析及代码生成等&lt;br /&gt;
3.作用域：负责收集并维护由所有声明的标识符组成的理询，确定肖前执行的代码对这些标识符的访问权限&lt;/p&gt;

&lt;pre&gt;var a = 2&lt;/pre&gt;

&lt;p&gt;例如碰到上以代码的执行时编译器会作如下处理：&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;1.&lt;code class=&quot;highlighter-rouge&quot;&gt;var a&lt;/code&gt;,编译器会查询作用域中是否已经有对该变量在于同一个作用域的集合中，如果已有了，编译器会忽略并继续工作;否则会要求作用域在当前作用域的集合中声明一个新的变量，命名为a。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;2.之后编译器会为引擎生成运行时所需要的代码，用来处理&lt;code class=&quot;highlighter-rouge&quot;&gt;a=2&lt;/code&gt;的赋值操作，引擎第一步会问作用域是否在当前作用域集合中有a的变量，若有则使用这个变量，如果没有，引擎则会继续查找该变量。&lt;/p&gt;

&lt;p&gt;3.在该例子中，引擎为变量&lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 进行LHS（赋值操作）查询。另一个查找类型 RHS（取到它的源值）&lt;/p&gt;

&lt;pre&gt;例1：console.log(a)  //可以看出对`a`的引用是一个RHS引用&lt;/pre&gt;

&lt;pre&gt;例2：a = 2 ;  //可以看出对`a`的引用是一个LHS引用&lt;/pre&gt;

&lt;pre&gt;例3：function foo(i) {
        console.log(i)  // 查找i并打印出来是对i的源值查找操作 此为RHS操作
    }
    foo(2)  //调用foo函数并为i赋值为2 此为LHS 操作
&lt;/pre&gt;

&lt;h3 id=&quot;作用域嵌套&quot;&gt;作用域嵌套&lt;/h3&gt;

&lt;p&gt;当一个块或函数嵌套在另一个块或函数中，就会发生了作用域的嵌套。所以在当前作用域中无法找个某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量或找到最外层的作用域（全局）为止。&lt;/p&gt;

&lt;pre&gt;function foo(a) {
    console.log(a + b) //在这里对a是RHS操作，对b的RHS引用无法在foo函数内完成，这里可以在上一级作用域中完成（此例是在全局中）
}
var b = 2;
foo(1)  =&amp;gt; 3   //调用foo()函数 对a是LHS操作&lt;/pre&gt;

&lt;p&gt;注：引擎从当前执行作用域开始查找变量，若找不到，则向上一级查找。如果找到最外层即全局作用域时，不管找到与否，过程都将停止。&lt;/p&gt;

&lt;p&gt;如图，可作参考
&lt;img src=&quot;http://ozc5dgoun.bkt.clouddn.com/%E4%BD%9C%E7%94%A8%E5%9F%9F.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;会发生的异常&quot;&gt;会发生的异常&lt;/h3&gt;

&lt;p&gt;上面提到的LHS 与 RHS，因为在变量还没有声明（其他作用域或全局作用域都无法找到）的情况下，这两种的查询行为是不一样的。&lt;/p&gt;

&lt;pre&gt;
    function foo(a) {
        console.log(a + b); // a:执行RHS操作  但是对b的RHS操作无法找到变量，此为`未声明`的变量，在任何作用域下都找不到它。
        b = a;
    }
    foo(2);   // 调用foo()函数，执行LHS操作

    注：如RHS查询（在任何作用域中）找不到变量，引擎会抛出`ReferenceError`的异常。此异常是重要的异常类型。

    不成功的RHS引用会导致ReferenceError异常。不成功的LHS引用会导致自动隐式创建一个全局变量(非严格模式下)，该变量使用LHS引用的目标作为标识符，或者抛出ReferenceError异常(严格模式下)
&lt;/pre&gt;

&lt;h3 id=&quot;词法阶段&quot;&gt;词法阶段&lt;/h3&gt;

&lt;p&gt;词法作用域是定义在词法阶段的作用域。&lt;/p&gt;

&lt;p&gt;词法作用域是由你在写代码时将变量和块作用域写在哪里决定的，所以当词法分析器处理代码时会保持作用域不变(大部份情况下)&lt;/p&gt;

&lt;pre&gt;
例1: function foo(a) {
    var b = a*2;
    function bar(c) {
        console.log(a,b,c);
    }
    bar(b*3)
    }
    foo(2);
&lt;img src=&quot;http://ozc5dgoun.bkt.clouddn.com/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F1.png&quot; alt=&quot;&quot; /&gt;
&lt;/pre&gt;
&lt;pre&gt;例2：
    function foo(){
        console.log(a);
    }
    function bar(){
        var a = 2;
        foo();
    }
    var a=1;
    bar();  =&amp;gt; 1
    //如果javascript具有动态作用域，理论上，会输出2
    &lt;img src=&quot;http://ozc5dgoun.bkt.clouddn.com/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F2.png&quot; alt=&quot;&quot; style=&quot;width:300px&quot; /&gt;
&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的(this也是)。词法作用域关注函数是在何处声明的，而动态作用域是关注函数从何处调用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;期骗词法&quot;&gt;期骗词法&lt;/h3&gt;

&lt;h4 id=&quot;1eval&quot;&gt;1.eval&lt;/h4&gt;

&lt;p&gt;js中的Eval()函数可接受一个字符串为参数，并将其中内容视为好像在书写时就存在程程序中这个位置的代码。&lt;/p&gt;

&lt;h4 id=&quot;2with&quot;&gt;2.with&lt;/h4&gt;

&lt;p&gt;with声明实际是根据你传递给它的对象凭空创建了一个全新的词法作用域。&lt;/p&gt;

&lt;p&gt;注：不推荐使用这两个机制&lt;/p&gt;

&lt;h3 id=&quot;函数中的作用域&quot;&gt;函数中的作用域&lt;/h3&gt;

&lt;p&gt;属于这个函数的全部变量都可以在整个函数的范围内使用和复用。&lt;/p&gt;

&lt;pre&gt;例：
    function foo(a){    //foo()的作用域包括了(b,bar(),c)
        var b = 2;
        function bar(){  //bar()的作用域包括了它自己的标识符
            ...
        }
        var c = 3;

    }
    bar(); // 错误   由于bar是foo()作用域包含的，所以不能从全局作用域中访问
    console.log(a,b,c) //错误  同理
&lt;/pre&gt;

&lt;h3 id=&quot;隐藏内部实现&quot;&gt;隐藏内部实现&lt;/h3&gt;

&lt;p&gt;一般来讲，都是先声明一个函数，然后在函数内添加代码;同时，可以用函数声明的方式对代码进行包装，就是把这些代码“隐藏”了的意思。&lt;/p&gt;

&lt;p&gt;就是说，可以把变量和函数包裹在一个函数的作用域中，用这个作用域来“隐藏”它们。&lt;/p&gt;

&lt;pre&gt;例：
    function foo(a){
        b = a + bar(a *2);
        console.log(b*3);
    }
    function bar(a){
        return a-1;
    }
    var b ;
    foo(2); =&amp;gt; 15
    //这里需要注意的是 变量b和bar()应该是foo()内部具体实现的‘私有’内容。放在全局作用域不仅没有必要，而且是‘危险’，所以更‘隐藏’的设计会更加的私有化，例如

    function foo(a){
        function bar(a) {
            return a -1 ;
        }
        var b;
        b = a + bar(a*2);
        console.log(b*3)
    }
    foo(2) =&amp;gt; 15

    //这样一来，b和bar()都无法从外部被访问，只被foo()控制。
&lt;/pre&gt;

&lt;h3 id=&quot;函数作用域&quot;&gt;函数作用域&lt;/h3&gt;

&lt;p&gt;先看一个例子:&lt;/p&gt;
&lt;pre&gt;
    var a = 2;
    function foo() {
        var a = 3;
        console.log(a); =&amp;gt;3
    }
    foo();
    console.log(a); =&amp;gt;2
&lt;/pre&gt;

&lt;p&gt;该例子本身没毛病，但有点不太精致，会导致一些额外的问题&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;必须声明一个具明函数foo(),foo名子本身‘污染’了所在作用域(全局)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;必须是通过一个函数名foo()来调用这个函数才能运行其中代码&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;后来，js提供了可以解决这两个问题的办法：&lt;/p&gt;

&lt;pre&gt;
    var a = 2;
    (function foo(){
        var a = 3;
        console.log(a); =&amp;gt; 3
    })();
    console.log(a); =&amp;gt; 2
    
    // 自执行匿名函数
    // (function foo(){...})作为函数表达示意味着foo只能在...所代表的位置中访问，外部作用域则不可访问
    // 函数会被当作 &lt;b style=&quot;color:red;&quot;&gt;函数表达示&lt;/b&gt; 而不是一个标准的函数声明来处理
&lt;/pre&gt;

&lt;pre&gt;
&lt;b&gt;*区别函数声明 和 表达示的方法&lt;/b&gt;
&amp;gt; 如果function 是声明中的第一个词 =&amp;gt; 函数声明
&amp;gt; 否则就是一个函数表达示
&lt;/pre&gt;

&lt;h3 id=&quot;立即执行函数表达示&quot;&gt;立即执行函数表达示&lt;/h3&gt;

&lt;p&gt;IIFE : 立即执行函数表达示&lt;/p&gt;

&lt;pre&gt;
    var a = 2;
    (function foo(){
        var a = 3;
        console.log(a); =&amp;gt; 3
    })();
    console.log(a); =&amp;gt; 2
    
&lt;/pre&gt;

&lt;p&gt;IIFE的进阶用法：把它们当作函数调用并传递参数进去&lt;/p&gt;
&lt;pre&gt;
    var a = 2;
    (function foo(global){
        var a = 3;
        console.log(a); =&amp;gt; 3 
        console.log(global.a); = &amp;gt;2
    })(window);
    console.log(a);  =&amp;gt; 2
&lt;/pre&gt;

&lt;h3 id=&quot;块作用域&quot;&gt;块作用域&lt;/h3&gt;

&lt;p&gt;常见的javascript代码&lt;/p&gt;
&lt;pre&gt;
    for(var i=0;i&amp;lt;10;i++) {
        console.log(i)
    }
    console.log(i); =&amp;gt; 10
    //在for循环内部的上下文中使用i，
&lt;/pre&gt;

&lt;h4 id=&quot;let&quot;&gt;let&lt;/h4&gt;

&lt;p&gt;前面的不是重点，重点是让你心里知道块作用域的用法及其内涵&lt;/p&gt;

&lt;p&gt;ES6 改变了现状，引入&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; 关键字，是var以处的另一种变量声明方式 。&lt;/p&gt;

&lt;p&gt;对ES6不太理解的可以去看下&lt;a href=&quot;http://es6.ruanyifeng.com/&quot;&gt;ES6的官方文档&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
    {
      let a = 10;
      var b = 1;
    }
    a =&amp;gt; ReferenceError: a is not defined
    b =&amp;gt; 1
&lt;/pre&gt;
&lt;pre&gt;
    for (let i = 0; i &amp;lt; 10; i++) {
      // ...
    }

    console.log(i);
    // ReferenceError: i is not defined
&lt;/pre&gt;

&lt;p&gt;&lt;b style=&quot;color:red;&quot;&gt;注：let 命令不存在变量提升&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; 命令会发生“变量提升”，即变量可以在声明之前使用(输出undefind)&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; 命令则改变了语法行为，所声明的变量一定是要在声明后使用，否则报错(报错：ReferenceError)。&lt;/p&gt;

&lt;h3 id=&quot;const&quot;&gt;const&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;除了let以外,ES6还引入了const,同样也可以用来创建作用域变量，但其值是固定的常量，之后若试图修改值都会报错。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;
    const a = 3;
    a // 3

    a = 4;
    // TypeError: Assignment to constant variable.
&lt;/pre&gt;

&lt;h3 id=&quot;提升&quot;&gt;提升&lt;/h3&gt;

&lt;p&gt;引擎会在解释javascript代码之前首先对其进行编译。编译阶段中的一部份工作就是找到所有的声明，并用合适的作用域将它们关联起来。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;正确说法就是，包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;变量提升&quot;&gt;变量提升&lt;/h3&gt;

&lt;p&gt;可以看个简单的例子：&lt;/p&gt;

&lt;pre&gt;var a = 1;&lt;/pre&gt;

&lt;p&gt;可能会被认为是一个声明，但在之前，javascript会将其看成两个声明 &lt;code class=&quot;highlighter-rouge&quot;&gt;var a;&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;a = 1&lt;/code&gt; ，第一个定义声明是在编译阶段;第二个赋值声明 会被留在原地等待执行阶段&lt;/p&gt;

&lt;p&gt;所以，上面代码会以如下顺序处理：&lt;/p&gt;

&lt;pre&gt;
    var a ;
    a = 1;
    console.log(a) =&amp;gt;1
&lt;/pre&gt;

&lt;h3 id=&quot;函数提升&quot;&gt;函数提升&lt;/h3&gt;

&lt;pre&gt;
    // 函数声明会被提升

    foo();
    function foo() {
        console.log(a);
        var a = 1;
    }

    //以下函数声明可以理解为下面的形式:

    function foo() {
        var a ;
        console.log(a); =&amp;gt; undefined
        a = 1;
    }
    foo();
&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;函数声明会被提升 ，但函数表达示却不会被提升&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;
    foo();  // 不是ReferenceError ，而是TypeError
    var foo = function bar() {
        ...
    }
&lt;/pre&gt;

&lt;pre&gt;
    foo();  // 不是ReferenceError ，而是TypeError
    bar();  // ReferenceError
    var foo = function bar() {
        ...
    }

    经过提升后的代码：

    var foo;
    foo();
    bar();
    foo = function () {
        var bar = ....
        //...
    }
&lt;/pre&gt;

&lt;h3 id=&quot;函数优先&quot;&gt;函数优先&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;函数声明和变量声明都会被提升，但函数声明优先于变量，函数声明会被提升到普通变量之前。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;重复的变量声明会被忽略，只剩下赋值操作，多个函数声明可以覆盖前一个。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;
例1：
    var a;
    a = 1;
    foo();
    function foo(){...}

    提升之后的形式如下：
    
    function foo(){...}
    var a ; 
    a = 1;
    foo();
&lt;/pre&gt;

&lt;pre&gt;
例2：
    foo();  =&amp;gt; 1
    var foo;
    function foo() {
        console.log(1);
    }
    foo = function() {
        console.log(2);
    };

    提升后的代码形式如下：

    function foo(){
        console.log(1);
    }
    /*var foo;*/
    foo(); =&amp;gt; 1
    foo = function(){
        console.log(2);
    };

&lt;/pre&gt;

&lt;p&gt;var foo 虽然是出现在function foo()…的声明之前，但它是重复声明 (因此被忽略)，因为函数声明会被提升 到普通这变量之前。&lt;/p&gt;

&lt;pre&gt;
    foo(); = &amp;gt; 3
    function foo(){
        console.log(1)
    }
    var foo = function () {
        console.log(2)
    }
    function foo(){
        console.log(3)
    }

    提升后的代码形式如下：
    function foo(){console.log(1)}
    function foo(){console.log(3)}
    foo(); =&amp;gt; 3
    /*var foo;*/
    foo = function() {console.log(2)}

&lt;/pre&gt;

&lt;h3 id=&quot;调用的位置&quot;&gt;调用的位置&lt;/h3&gt;

&lt;p&gt;this关键字是js中最复杂的机制之一，被定义在所有的函数的作用域中。&lt;/p&gt;

&lt;p&gt;当一个函数被调用时，会创建一个活动记录(也称执行上下文)。该记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息，this就是记录的其中一个属性，会在函数执行的过程中用到。&lt;/p&gt;

&lt;p&gt;调用位置：函数在代码中被调用的位置(而不是声明的位置)&lt;/p&gt;

&lt;h3 id=&quot;绑定规则&quot;&gt;绑定规则&lt;/h3&gt;

&lt;p&gt;首先得先找到函数的调用位置，然后再进行以下四条规则的判断，以及多条规则下都可使用的情况下的优先级别是如何进行判断的。&lt;/p&gt;

&lt;h4 id=&quot;默认绑定&quot;&gt;默认绑定&lt;/h4&gt;

&lt;p&gt;先看如下代码：&lt;/p&gt;

&lt;pre&gt;
    function foo() {
        console.log(this.a); =&amp;gt; 2
    }
    var a = 2; 
    foo(); //函数调用的位置，在非严格模式下可看作为 window.foo()的调用
&lt;/pre&gt;

&lt;p&gt;在这里需要注意的是:这里的this.a最后打印出是2，为什么？因为函数在调用的时候，其实可以看作为全局调用，即window.foo()。所以，函数调用的位置可看作是全局window是调用，这可以看作为默认调用。所以foo()函数里的this就是指向全局，而this.a解析成全局变量a。&lt;/p&gt;

&lt;p&gt;注：如果使用严格模式下，那么，this的绑定与foo()的调用位置无关。&lt;/p&gt;

&lt;pre&gt;
    functon foo(){
        &quot;use strict&quot;;
        console.log(this.a)
    }
    var a = 2;
    foo(); //TypeError: this is undefined
&lt;/pre&gt;

&lt;h4 id=&quot;隐式绑定&quot;&gt;隐式绑定&lt;/h4&gt;

&lt;p&gt;再看看一段代码来理解隐式绑定的意思&lt;/p&gt;

&lt;pre&gt;
    function foo() {
        console.log(this.a); =&amp;gt;2
    }
    var obj = {
          a: 2,
          foo:foo  
    };
    obj.foo(); // 调用的位置
&lt;/pre&gt;

&lt;p&gt;按照我自己的理解：先看函数的调用位置。再看是否是默认绑定，如果不是就看是谁调用了这个函数，在这里可以显而易见的知道，是obj这个对象调用了foo()，即调用位置会使用obj上下文来引用函数，这样隐匿绑定规则会把函数用中的this绑定到这个上下文对像，&lt;/p&gt;

&lt;p&gt;所以调用foo()的时候this会被绑定到obj。结果就是this.a = obj.a&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对像属性引用链中只有最后一层会影响调用位置。看例子：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;
    functon foo() {
        console.log(this.a)  =&amp;gt; 42
    }
    var obj2 = {
        a:42,
        foo:foo 
    };
    var obj1 = {
        a:2,
        obj2:obj2
    };
    obj1.obj2.foo();  // foo函数调用的位置
&lt;/pre&gt;

&lt;p&gt;这里和上一个例子不同的是foo调用的位置。这时候肯定一脸蒙蔽，这个怎么判断this是调用到哪个对像的上下文。根据“圆点”号的概念，查找最后调用的那个对象作为this的指向上下文。obj1.obj2.foo()，可以看出最后调用foo()的是obj2，所以this的上下文指向obj2，所以结果输出为 42&lt;/p&gt;

&lt;h4 id=&quot;显式绑定&quot;&gt;显式绑定&lt;/h4&gt;

&lt;p&gt;可以使用函数的call() 和 apply() 方法来进行显式绑定。&lt;/p&gt;

&lt;p&gt;老样子，看例子啦&lt;/p&gt;

&lt;pre&gt;
    function foo() {
        console.log(this.a);
    }
    var obj = {a:3};
    foo.call(obj);
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;通过使用foo.call(obj)，简单理解为：调用foo()函数并强制将this绑定到obj对象上。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;从this的绑定角度来讲。call() 和 apply() 的操作是一样，但区别在于 传参的的情况下，foo.apply(‘这里是数组’)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;硬绑定&quot;&gt;硬绑定&lt;/h5&gt;

&lt;p&gt;显示绑定仍然无法解决丢失绑定的问题&lt;/p&gt;

&lt;pre&gt;
    function foo(){
        console.log(this.a);
    }
    var obj = {
        foo.call(obj);
    };
    bar(); =&amp;gt;2
    setTimeout(bar,100); =&amp;gt;2

    //硬绑定的bar，不可能再修改它的this
    bar.call(window); =&amp;gt; 2
&lt;/pre&gt;

&lt;p&gt;创建bar()函数，并手动foo.call(obj),强制把foo绑定到obj上。之后无论如何调用函数bar，都会手动在obj上调用foo。所以这种绑定是一种显式的强制绑定，即硬绑定&lt;/p&gt;

&lt;h3 id=&quot;new绑定&quot;&gt;new绑定&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Javascript中的“构造函数”只是一些使用new操作符时被调用的函数。它们并不属于某个类，也不会实例化一个类(即js中没有类的概念)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用new来调用函数，或者是在构造函数调用的时候，有如下操作：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;创建(构造)一个全新的对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这个新对象会被执行(原型)连接&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;新对象会绑定到函数调用的this&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果函数没有返回其他对象，new表达式中的函数调用会自动返回这个新对象&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;例：&lt;/p&gt;
&lt;pre&gt;
    function foo(a) {
        this.a = a;
    }
    var bar = new foo(3);
    console.log(bar.a ); =&amp;gt; 2
&lt;/pre&gt;

&lt;p&gt;new 调用foo()时，会构造一个新对象并绑定到foo()调用中的this上。&lt;/p&gt;

&lt;h3 id=&quot;优先级&quot;&gt;优先级&lt;/h3&gt;

&lt;!-- new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定 --&gt;

&lt;blockquote&gt;
  &lt;p&gt;new 和 call/apply无法一起使用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以上四种绑定规则的使用先后推断如下：
 1、函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var bar = new foo(); &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2、函数是否通过 call、apply （显示绑定）或者硬绑定？如果是的话，this 绑定的是指定的对象。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; var bar = foo.call(obj2); &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3、函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; var bar = obj1.foo(); &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;4、如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到全局对象。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; var bar = foo(); &lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;绑定例外&quot;&gt;绑定例外&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;若把&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt; 作为&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;的绑定对象传入&lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;applh&lt;/code&gt;,或&lt;code class=&quot;highlighter-rouge&quot;&gt;bind&lt;/code&gt;,这些值在调用的时候会被忽略，实际应用的是默认绑定规则&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;
    function foo(){
        console.log(this.a); =&amp;gt; 2
    }
    var a = 2;
    foo.call(null)
&lt;/pre&gt;

&lt;p&gt;什么情况下会在绑定下传入&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;？&lt;/p&gt;

&lt;p&gt;常见的做法是使用apply(…)来“展开”一个数组，并当作参数传入一个函数。类似的，bind(…)可对参数进行柯里化（预先设置一些参数）&lt;/p&gt;

&lt;pre&gt;
    function foo(a,b) {
        console.log(&quot;a:&quot; + a + &quot;,b:&quot; + b);
    }
    //把数组“展开”成参数 
    foo.apply(null,[2,3]); //a:2,b:3
    
    //使用bind(...)进行柯里化
    var bar = foo.bind(null ,2);
    bar(3);  // a:2,b:3
&lt;/pre&gt;

&lt;p&gt;这两种方法都需要传入一个参数当this的绑定对象。若函数并不关心this的话，你仍需要传入一个占位符，null会是一个不错的选择&lt;/p&gt;

&lt;h4 id=&quot;更安全的this&quot;&gt;更安全的this&lt;/h4&gt;

&lt;p&gt;一种更安全的做法是传入一个特殊的对象，把this绑定到这个对象不会对你的程序产生任何副作用。
在js中创建一个空对象最简单的方法 &lt;code class=&quot;highlighter-rouge&quot;&gt;Object.create(null)&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.create(null)&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;{}&lt;/code&gt;很像，但并不会创建Object.prototype这委托，所以比&lt;code class=&quot;highlighter-rouge&quot;&gt;{}&lt;/code&gt;更空&lt;/p&gt;

&lt;pre&gt;
    function foo(a,b) {
        console.log(&quot;a:&quot; + a + &quot;,b:&quot; + b);
    }

    var &amp;amp; = Object.create(null);  //空对象 
    
    //把数组“展开”成参数 
    foo.apply(&amp;amp;,[2,3]); //a:2,b:3
    
    //使用bind(...)进行柯里化
    var bar = foo.bind(&amp;amp; ,2);
    bar(3);  // a:2,b:3
&lt;/pre&gt;

&lt;blockquote&gt;

&lt;/blockquote&gt;</content><author><name>MengTing Xu</name></author><category term="js" /><category term="documentation" /><category term="sample" /><summary type="html">好记性不如烂笔头，又重温一变你不知道的js，为防止自己记性出现短暂性失忆，哈哈，所以记下相关基础的知识点，知识点有但内容不全，主要是自己觉得自己一看就能理解的重要点，本文章主要参考《你不知道的javascript》,感谢这本书和作者。路过的朋友也可以学习一下！</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3E%22cutting.jpg%22,%20%22teaser%22=%3E%22cutting-teaser.jpg%22,%20%22credit%22=%3Enil,%20%22creditlink%22=%3E%22%22%7D" /></entry><entry><title type="html">设计师平台</title><link href="http://localhost:4000/project/2016/12/18/designer-platform.html" rel="alternate" type="text/html" title="设计师平台" /><published>2016-12-18T00:00:00+08:00</published><updated>2016-12-18T00:00:00+08:00</updated><id>http://localhost:4000/project/2016/12/18/designer-platform</id><content type="html" xml:base="http://localhost:4000/project/2016/12/18/designer-platform.html">&lt;h3 id=&quot;一简介&quot;&gt;一、简介&lt;/h3&gt;

&lt;p&gt;设计师平台 主要力致于工程项目的发布,接洽等。整体响应式布局，适应各种设备尺寸，简洁大方。即内部管理软件。&lt;/p&gt;

&lt;h3 id=&quot;二项目截图&quot;&gt;二、项目截图&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://ozc5dgoun.bkt.clouddn.com/sj-01.jpg&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;http://ozc5dgoun.bkt.clouddn.com/sj-01.jpg&quot; alt=&quot;&quot; /&gt;
&lt;/a&gt;
&lt;a href=&quot;http://ozc5dgoun.bkt.clouddn.com/sj-02.jpg&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;http://ozc5dgoun.bkt.clouddn.com/sj-02.jpg&quot; alt=&quot;&quot; /&gt;
&lt;/a&gt;
&lt;a href=&quot;http://ozc5dgoun.bkt.clouddn.com/sj-03.jpg&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;http://ozc5dgoun.bkt.clouddn.com/sj-03.jpg&quot; alt=&quot;&quot; /&gt;
&lt;/a&gt;
&lt;a href=&quot;http://ozc5dgoun.bkt.clouddn.com/sj-04.jpg&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;http://ozc5dgoun.bkt.clouddn.com/sj-04.jpg&quot; alt=&quot;&quot; /&gt;
&lt;/a&gt;&lt;/p&gt;</content><author><name>XuMT</name></author><category term="project" /><category term="documentation" /><category term="sample" /><summary type="html">一、简介</summary></entry><entry><title type="html">TechBank 科库</title><link href="http://localhost:4000/project/2016/10/08/TechBank.html" rel="alternate" type="text/html" title="TechBank 科库" /><published>2016-10-08T00:00:00+08:00</published><updated>2016-10-08T00:00:00+08:00</updated><id>http://localhost:4000/project/2016/10/08/TechBank</id><content type="html" xml:base="http://localhost:4000/project/2016/10/08/TechBank.html">&lt;h3 id=&quot;一简介&quot;&gt;一、简介&lt;/h3&gt;

&lt;p&gt;TechBank 科库是一个专注医疗健康行业，集跨境技术、孵化、投资于一体的平台。&lt;/p&gt;

&lt;h3 id=&quot;二项目地址&quot;&gt;二、项目地址&lt;/h3&gt;

&lt;p&gt;TechBank 科库： &lt;a href=&quot;http://www.techbankcapital.com&quot;&gt;http://www.techbankcapital.com&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;三项目截图&quot;&gt;三、项目截图&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://ozc5dgoun.bkt.clouddn.com/tb-01.jpg&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;http://ozc5dgoun.bkt.clouddn.com/tb-01.jpg&quot; alt=&quot;&quot; /&gt;
&lt;/a&gt;
&lt;a href=&quot;http://ozc5dgoun.bkt.clouddn.com/tb-02.jpg&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;http://ozc5dgoun.bkt.clouddn.com/tb-02.jpg&quot; alt=&quot;&quot; /&gt;
&lt;/a&gt;
&lt;a href=&quot;http://ozc5dgoun.bkt.clouddn.com/tb-03.jpg&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;http://ozc5dgoun.bkt.clouddn.com/tb-03.jpg&quot; alt=&quot;&quot; /&gt;
&lt;/a&gt;&lt;/p&gt;</content><author><name>XuMT</name></author><category term="project" /><category term="documentation" /><category term="sample" /><summary type="html">一、简介</summary></entry><entry><title type="html">上海金曲软件公司企业网站</title><link href="http://localhost:4000/project/2016/08/11/project-for-jq-company-website.html" rel="alternate" type="text/html" title="上海金曲软件公司企业网站" /><published>2016-08-11T00:00:00+08:00</published><updated>2016-08-11T00:00:00+08:00</updated><id>http://localhost:4000/project/2016/08/11/project-for-jq-company-website</id><content type="html" xml:base="http://localhost:4000/project/2016/08/11/project-for-jq-company-website.html">&lt;h3 id=&quot;一简介&quot;&gt;一、简介&lt;/h3&gt;

&lt;p&gt;上海金曲信息技术有限公司企业网站 整体响应式布局，适应各种设备尺寸，简洁大方。&lt;/p&gt;

&lt;h3 id=&quot;二项目地址&quot;&gt;二、项目地址&lt;/h3&gt;

&lt;p&gt;上海金曲信息技术有限公司 : &lt;a href=&quot;http://www.jinqu.cn:2016/&quot;&gt;http://www.jinqu.cn:2016/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;三项目截图&quot;&gt;三、项目截图&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://ozc5dgoun.bkt.clouddn.com/jq_02.jpg&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;http://ozc5dgoun.bkt.clouddn.com/jq_02.jpg&quot; alt=&quot;&quot; /&gt;
&lt;/a&gt;
&lt;a href=&quot;http://ozc5dgoun.bkt.clouddn.com/jq_01.jpg&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;http://ozc5dgoun.bkt.clouddn.com/jq_01.jpg&quot; alt=&quot;&quot; /&gt;
&lt;/a&gt;&lt;/p&gt;</content><author><name>XuMT</name></author><category term="project" /><category term="documentation" /><category term="sample" /><summary type="html">一、简介</summary></entry><entry><title type="html">中设软件公司企业网站</title><link href="http://localhost:4000/project/2016/07/20/project-for-company's-page.html" rel="alternate" type="text/html" title="中设软件公司企业网站" /><published>2016-07-20T00:00:00+08:00</published><updated>2016-07-20T00:00:00+08:00</updated><id>http://localhost:4000/project/2016/07/20/project-for-company's-page</id><content type="html" xml:base="http://localhost:4000/project/2016/07/20/project-for-company's-page.html">&lt;h3 id=&quot;一简介&quot;&gt;一、简介&lt;/h3&gt;

&lt;p&gt;中设软件公司企业网站 整体响应式布局，适应各种设备尺寸，简洁大方。&lt;/p&gt;

&lt;h3 id=&quot;二项目地址&quot;&gt;二、项目地址&lt;/h3&gt;

&lt;p&gt;中设软件公司企业网站 : &lt;a href=&quot;http://www.zssoftware.cn&quot;&gt;http://www.zssoftware.cn&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;三项目截图&quot;&gt;三、项目截图&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://ozc5dgoun.bkt.clouddn.com/zs_2.jpg&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;http://ozc5dgoun.bkt.clouddn.com/zs_2.jpg&quot; alt=&quot;&quot; /&gt;
&lt;/a&gt;
&lt;a href=&quot;http://ozc5dgoun.bkt.clouddn.com/zs_1.jpg&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;http://ozc5dgoun.bkt.clouddn.com/zs_1.jpg&quot; alt=&quot;&quot; /&gt;
&lt;/a&gt;&lt;/p&gt;</content><author><name>XuMT</name></author><category term="project" /><category term="documentation" /><category term="sample" /><summary type="html">一、简介</summary></entry></feed>